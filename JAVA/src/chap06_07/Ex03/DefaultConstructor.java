package chap06_07.Ex03;
// 기본 생성자 :class A는 기본 생성자가 생략되어 있다.
// 일반적으로 클래스 블락의 1번째로는 필드, 2. 생성자 3. 메소드 형식으로 작성한다.
//생성자의 역할 : 1. 객체 생성, 2. 필드의 값을 초기화

class A{ //외부클래스, 외부클래스는 public키를 넣을수없음. 이게들어간키는 자바파일이름과 같아야함 
	int m; 	//필드 : 데이터타입 변수명 //클래스 블락에 선언된 변수
 				//Heap영역에 저장, 객체화 시켜야 사용가능
				//예외) static 키를 넣으면 그냥 사용가능
				//힙 영역의 RAM에는 반드시 초기값이 들어가야 함
	
//	A () { } // <===== 기본 생성자 : 클래스 이름과 동일하면서 리턴타입이 없는 메소드를 생성자라고 호칭함.
			// 기본 생성자는 생략 가능 하다.
			// 기본 생성자는 매개변수도 없고, 실행부도 가지지않는 생성자
	
	void work() { //메소드 : 리턴타입(int,void....) 메소드명 (인풋 매개변수) {메소드 실행하는 실행부}
					// 메소드는 반드시 호출해야 작동 : work()
				//메소드 블락에 선언된 변수는 지역변수
	System.out.println(m);//0	//m : RAM(메모리)의 값을 가지고 옴
	
	}
	
}

class B{
	int m; //m은 Heap영역에 저장이 되고 기본값으로 0을 출력
	
	B () {} //기본 생성자는 생략 가능하다. 객체의 필드에 초기값을 기본값으로 출력
	
	void work() {
		System.out.println(m); // 0 //메모리의 초기값이 0을 출력
	}
	
}
//객체 생성시 생산자를 통해서 필드에 초기값을 할당하고 객체 생성,

class C{
	int m;
	// C () {} 기본생성자			//기본 생성자는 생략됨, 다른 생성자가 존재하는 경우 외부에서 기본 생성자 호출시 기본 생성자는 생략되면 안된다. 
	C (int c){ // 생성자의 인풋 값을 받아서 메모리의 기본값으로 m변수의 값을 로드 시킨다
		 m = c;
	 }
	
	void work() {
		System.out.println(m); //m은 객체 생성시 생성자에 정수값을 넣어서 필드m을 초기화시켜준다. 
	}
			
}

class D{
	int m,n,l;
	
	D () {} //기본 생성자
	D (int m, int n){ //매개변수 2개
		this.m = m;  //this : 자기 자신의 객체, 지역변수가 아니라 필드의 변수를 알려줌
		this.n = n;
	}
	D(int a, int b, int c) { //매개 변수가 3개인 생성자
		m = a;
		n = b;
		l = c;
	}
	
	void work () {		//work()를 호출시 각각의 메모리의 값을 출력
		System.out.println("m :"+ m + ", n :"+ n + ", l :" + l);
	}
	
	
}


public class DefaultConstructor {

	public static void main(String[] args) {
		//클래스 내에 포함될수 있는 것 : 1. 필드 2.메소드 3.생성자 4.이너클래스 (innerClass)
		//생성자의 2가지 특징 : 1. 클래스 이름과 동일한 이름을 가진 메소드를 생성자라고 한다. 		// 2. 생성자는 반환 타입이 없다. (메소드는 반환타입이 있다)
		//생성자를 사용하는 이유 : 객체를 생성할때 필드의 값을 초기화 하면서 객체를 생성하고자 할때 사용.
		//클래스 내에서 필드의 초기 값은 일반적으로 할당하지 않는다. 초기값을 넣으면 객체 초기값이다 그거로설정?
		//클래스의 객체를 생성할때 초기값을 할당하면서 객체를 생성할때 
		
		//객체를 생성할때, 반드시 생성자를 호출, A a = newA(); <====객체 생성 구문
		
		//기본 생성자 (Default Constructor) :
			// 매개변수인풋값이 생략된 //인풋 매개변수가 없는 생성자
			// 실행부터 값도 비어있는 상태의 생성자.
			//기본 생성자 생략 가능 하다,
			//생략 되어 있을 경우, 컴파일러가 자동으로 생성해서 컴파일,
			//클래스 내의 기본 생성자 이외의 다른 생성자가 존재하는 경우, 기본 생성자 호출시 생략되면 안된다.
		A a = new A(); // A(): 기본 생성자 호출. <<< 생성자 생략됨>>>
						//객체 생성시 반드시 생성자를 호출 해야한다.
		a.work(); // 0
		
		
		B b = new B(); // << 기본 생성자 호출 >>

		b.work(); // 0 <== 객체의 초기값 출력 :
		
		C c = new C(3); // <<생성자 호출시 기본값을 인풋해서 매모리 필드에 초기값 구성>>
		c.work(); //객체 생성시 기본 기능 : 객체 생성과 + 필드의 값을 초기화
		
		C cc = new C(5);
		cc.work();
		
		C ccc = new C(10);
		ccc.work();
	
		// class C는 기본 생성자 가 생략 되어 잇다. //C() {}
		// class C는 인풋 매개변수가 하나인 생성자가 존재
		
		//C cccc=new C(); //오류 발생 : 기본생성자를 호출햇는데 다른생성자가 있는데 기본생성자를 생략한경우 오류발생.
		D d = new D(); //기본 생성자 호출, 객체 의 필드의 초기값(0,0,0)
		d.work(); //
		
		D dd = new D(3,4,5); //매개변수가 정수 3개인 생성자 호출
		dd.work();
		
		D ddd = new D(1,2); //매개 변수가 정수 2개인 생성자를 호출
		ddd.work();
		
		// 생성자 : 메소드 이름이 객체이름과 같고 리턴값이 없는 메소드
		// 객체 내의 필드의 값을 초기화 할때 오버로딩(Overloading)에 의해서 해당 생성자가 호출
			//오버로딩 : 메소드명(생성자명, 데이터 타입, 매개변수 개수)에 따라서 해당 메소드를 로딩한다. <==시그니쳐
			//오류가 발생되는 경우 : 데이터타입과 매개변수개수가 동일한경우
		
	}

}
